# Example: Broadband directional coupler generated by pyFIMM
# Written by Xuhao Wu
# If you want to use this as an example for generating a complex structure by FIMMWAVE, feel free
# and I am glad that I can help.
# If you want to use the code directly, please contact me or prof. Wim Bogaerts first.
import pyfimm as pf   # Every script must begin with this line
#pf.set_DEBUG()      # Enable Debugging output
import subprocess
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

subprocess.Popen(r'"C:\Program Files (x86)\PhotonD6.6.2\Fimmwave\bin64\fimmwave.exe" -pt 5101') # Open fimmwave software.
pf.connect()        # this connects to the FimmWave application. 

# Set Parameters (Your copy of FIMMWAVE has default values for these. You can change more than shown here. See __jaredwave.py
import os
ScriptPath, ScriptFile = os.path.split( os.path.realpath(__file__)  )                    # Get directory of this script


pf.set_working_directory(ScriptPath)       # Set this directory to the location of your script
pf.set_working_directory(ScriptPath)       # Set FimmWave directory to the location of your script (needed to capture output files)
pf.set_eval_type('n_eff')                  # FIMMWAVE will label modes by the effective index (options: n_eff or beta)
pf.set_mode_finder_type('stable')          # options: stable or fast
pf.set_mode_solver('vectorial FMM real')   # Three words, any permuation of: 'vectorial/semivecTE/semivecTM FDM/FMM real/complex' for RWG.  
pf.set_wavelength(1.55)                    # The unit of space is always 1 micrometer 
pf.set_N_1d(100)                           # # of 1D modes found in each slice (FMM solver only)
pf.set_NX(100)                             # # of horiz. grid points for plotting & FDM
pf.set_NY(100)                             # # of vertical grid points for plotting & FDM
pf.set_N(3)                                # # of modes to solve for

pf.set_material_database('Materials/refbase.mat')   # Use the material database provided by PhotonDesign.  Only one matDB can be used at a time - to use multiple, set up your matDB to `include` other files.

def taper_boundaries(w11, w12, w13, w31, w32, w33, l, num): #2 additional variables need to be added: the lengths of input/output wgs
    z = np.linspace(0, l, 5)
    y1 = np.array([WG_gap/2.+WG_width,WG_gap/2.+w11, WG_gap/2.+w12, WG_gap/2.+w13, WG_gap/2.+WG_width])
    y3 = np.array([-WG_gap/2.-WG_width,-WG_gap/2.-w31, -WG_gap/2.-w32, -WG_gap/2.-w33, -WG_gap/2.-WG_width])

    z_new = np.linspace(z.min(), z.max(),num)
    y2 = np.full(num, WG_gap/2.)
    y4 = np.full(num, -WG_gap/2.)

    y1_cs = CubicSpline(z, y1, bc_type=((1, 0.0), (1, 0.0)))
    y3_cs = CubicSpline(z, y3, bc_type=((1, 0.0), (1, 0.0)))

    return z_new, y1_cs(z_new), y2, y3_cs(z_new), y4

# Project Node - You must build a project node at the beginning of every script
wg_prj = pf.Project()              # Construct a Project object, pass a project name to the constructor (optional).
wg_prj.buildNode('BDC_pyfimm', overwrite=True)
dev = pf.Device()                  # The blank fimmprop subnode is made.
dev.buildNode(name='BDC', parent=wg_prj)

# layer thicknesses
t_substrate = 0.5 # should be smaller than 0.45 um to maintain single mode.
t_core = 0.22
t_clad = 0.5

clad = pf.Material('SiO2')           
#clad = pf.Material(1.4456)            # Construct a Material python object, pass a refractive index as the argument

core = pf.Material('Si')    # Si: defined in material database; two methods above are valid in pyfimm.

center1 = pf.Slice( clad(t_clad) + core(t_core, cfseg=True) + clad(t_substrate) )
center2 = pf.Slice( clad(t_clad) + core(t_core, cfseg=True) + clad(t_substrate) )
# The Core material here is also set as the Confinement Factor Segment.

side1 = pf.Slice( clad(t_clad+t_core+t_substrate) )
gap1 = pf.Slice( clad(t_clad+t_core+t_substrate) )
side2 = pf.Slice( clad(t_clad+t_core+t_substrate) )
# This is a bug of pyfimm actually; it doesn't support using an object too many times in the code (like using "side" 3 times and "center" twice to build the wg). 

# widths
WG_width = 0.3
WG_gap = 0.2
Clad_width = 1
b_separation = WG_gap + WG_width

strip = pf.Waveguide(  side1(Clad_width) + center1(WG_width) + gap1(WG_gap) + center2(WG_width) + side2(Clad_width) )                                                                 
# You can pass the Slice width to the Slice object with ()s

strip.buildNode(name='input_wg', parent=wg_prj)    # You can also set the parent & name while building.  
#You must always build the node!  This sends the actual Fimmwave commands to generate this waveguide in Fimmwave.

print "Calculating 'strip'..."
strip.calc()            # Tell FIMMWAVE to solve for the modes!
   
# plot the taper shape
# Taper_section
# what we want to optimize: 50/50 and 100/0 coupler.
T_length = 5.0 # using float here to maintain the step length value is a float. (only necessary in python 2.7)
num_segments = 3 # The number of control points in taper section is 3*2=6.
w11 = 0.4
w12 = 0.7
w13 = 0.6
w31 = 0.4
w32 = 0.2
w33 = 0.3
num = 50
strip_list = []
#T_strip = np.zero(num)

z_new, y1, y2, y3, y4 = taper_boundaries(w11, w12, w13, w31, w32, w33, T_length, num)   
plt.plot(z_new, y1, label='y1')
plt.plot(z_new, y2, label='y2')
plt.plot(z_new, y3, label='y3')
plt.plot(z_new, y4, label='y4')
plt.legend()
plt.show() # the derivative of curves at start/end points = 0.
# remember to close the fig window afterwards to let the code continue to run.

for i in range(num):
    w2 = y1[i] - y2[i]
    w4 = y4[i] - y3[i]
    w3 = WG_gap
    w1 = Clad_width + WG_width - w2
    w5 = Clad_width + WG_width - w4
    strip2 = pf.Waveguide(  side1(w1) + center1(w2) + gap1(w3) + center2(w4) + side2(w5) )
    strip_list.append(strip2)
    t_name = 'taper' + str(i)
    strip2.buildNode(name=t_name, parent=wg_prj)      # for loop to design cross sections of taper along propagation direction under the same parent project.
    strip2.calc()
    
    
# Design a FimmProp Device with the input/output waveguides and the taper/phase controlling section; Pass the lengths of each WG as arguments.
WG_length = 10
step_length = T_length/num # step length is a float.
# print "step_length = ", step_length
# section_list = [strip2(step_length)  for strip2 in strip_list]
# dev = pf.Device( strip(WG_length) + sum(section_list) +strip(WG_length) )
# Another way (above) to design fimmprop device, similar to camfr; not used here because of failing to combine with for loop.
pf.Exec("app.subnodes[1].subnodes[1].cdev.newwgsect(1,../input_wg,0)") # add a section in the fimmprop device
pf.Exec("app.subnodes[1].subnodes[1].cdev.eltlist[1].length="+str(WG_length))
pf.Exec("app.subnodes[1].subnodes[1].cdev.newsjoint(2)") # building up input wg and joint
# pyfimm also has combine pdpythonlib; so using py.Exec directly to replace fimm(pdapp).Exec.

for i in range(num):
    t_name = 'taper' + str(i)
    pf.Exec("app.subnodes[1].subnodes[1].cdev.newwgsect("+str(2*i+3)+",../{t_name})")
    pf.Exec("app.subnodes[1].subnodes[1].cdev.eltlist["+str(2*i+3)+"].length="+str(step_length))
    pf.Exec("app.subnodes[1].subnodes[1].cdev.newsjoint("+str(2*i+4)+")") # building up taper and joints after each slice
    
pf.Exec("app.subnodes[1].subnodes[1].cdev.newwgsect("+str(2*(num-1)+5)+",../input_wg,0)")
pf.Exec("app.subnodes[1].subnodes[1].cdev.eltlist["+str(2*(num-1)+5)+"].length="+str(WG_length)) # building up output wg and joint

# Mode setting
#Boundary conditions (1: PEC ; 2: PMC):
pf.Exec("app.subnodes[1].subnodes[1].lhsbc.type=1") # lefthand side: Metal boundary conditions are used to specify boundaries that behave as a Perfect Electric Conductor (PEC).
pf.Exec("app.subnodes[1].subnodes[1].rhsbc.type=1")
pf.Exec("app.subnodes[1].subnodes[1].topbc.type=2") # top side: Perfect Magnetic Conductor (PMC) boundary conditions.
pf.Exec("app.subnodes[1].subnodes[1].botbc.type=2")
# Setting boundary conditions
# About the boundary conditions setting: seen in the manual fimmwave pp. 129- :3.6. choosing boundary conditions. 

pf.Exec("app.subnodes[1].subnodes[1].lhsinput.inputtype = 2")
pf.Exec("app.subnodes[1].subnodes[1].lhsinput.setvec(0.5,0,0.5,0)")
pf.Exec("app.subnodes[1].subnodes[1].lhsinput.normalise = 1")
# input field setting 
# Here we use vector input: odd/even mode with same amplitude(so that light only shown in 1st wg at the entrance). details shown in the manual fimmwave pp. 338.

pf.Exec("app.subnodes[1].subnodes[1].update()")
lr11 = pf.Exec("app.subnodes[1].subnodes[1].cdev.smat.lr[1][1]")
lr12 = pf.Exec("app.subnodes[1].subnodes[1].cdev.smat.lr[1][2]")
lr21 = pf.Exec("app.subnodes[1].subnodes[1].cdev.smat.lr[2][1]")
lr22 = pf.Exec("app.subnodes[1].subnodes[1].cdev.smat.lr[2][2]")
# giving the scatter matrix. same as the operation "inspect the device s matrix" --> "display coefs as real/imag"; [1][1] means mode 1 coupling to mode 1 at the output port of the device.
    